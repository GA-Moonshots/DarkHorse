package org.firstinspires.ftc.teamcode.sensors.localizers;

import com.acmerobotics.roadrunner.Pose2d;
import com.acmerobotics.roadrunner.Vector2d;
import com.acmerobotics.roadrunner.ftc.Encoder;
import com.acmerobotics.roadrunner.ftc.OverflowEncoder;
import com.acmerobotics.roadrunner.ftc.PositionVelocityPair;
import com.acmerobotics.roadrunner.ftc.RawEncoder;
import com.qualcomm.robotcore.hardware.DcMotorEx;

import org.firstinspires.ftc.teamcode.config.Constants;
import org.firstinspires.ftc.teamcode.config.OdometryConfig;
import org.firstinspires.ftc.teamcode.core.CoreLocalizer;
import org.firstinspires.ftc.teamcode.core.CoreOpMode;
import org.firstinspires.ftc.teamcode.core.math.Vector;

import kotlin.NotImplementedError;

public class ThreeWheelLocalizer extends CoreLocalizer {
    private final Encoder left, right, center;
    private int leftPos, rightPos, centerPos;

    public ThreeWheelLocalizer(CoreOpMode opMode) {
        super(opMode);

        left = new OverflowEncoder(new RawEncoder(opMode.hardwareMap.get(DcMotorEx.class, Constants.LEFT_ODOMETRY_NAME)));
        right = new OverflowEncoder(new RawEncoder(opMode.hardwareMap.get(DcMotorEx.class, Constants.RIGHT_ODOMETRY_NAME)));
        center = new OverflowEncoder(new RawEncoder(opMode.hardwareMap.get(DcMotorEx.class, Constants.CENTER_ODOMETRY_NAME)));

        left.setDirection(DcMotorEx.Direction.REVERSE);
        update();
    }

    public void update() {
        PositionVelocityPair leftPosVel = left.getPositionAndVelocity();
        PositionVelocityPair rightPosVel = right.getPositionAndVelocity();
        PositionVelocityPair centerPosVel = center.getPositionAndVelocity();

        // left = dx+L*dTheta/2
        // right = dx-L*dTheta/2
        // center = dy +BdTheta

        double xDist = Math.abs(OdometryConfig.LEFT_X_POSITION - OdometryConfig.RIGHT_X_POSITION);

        // dTicks
        double dLeft = (leftPosVel.position - leftPos);
        double dRight = (rightPosVel.position - rightPos);
        double dCenter = (centerPosVel.position - centerPos);

        // should display dTick amount
        telemetry.addData("dLeft", dLeft);
        telemetry.addData("dRight", dRight);
        telemetry.addData("dCenter", dCenter);

        // Needs to be an angle
        double dTheta = (dRight - dLeft) / xDist;
        // dTicks still
        double dx = (dRight * OdometryConfig.LEFT_X_POSITION) - (dLeft * OdometryConfig.RIGHT_X_POSITION) / xDist;
        double dy = dCenter - OdometryConfig.CENTER_Y_POSITION * dTheta;

        // Vector Rotation based on new theta
        double theta = getHeading() + dTheta;

        // vector of dTicks
        Vector2d gradient = Vector.rotateVector(new Pose2d(dx, dy, theta));

        // ticks
        double x = getXPosition() + gradient.x;
        double y = getYPosition() + gradient.y;

        currentPose = new Pose2d(x, y, theta);
        leftPos = leftPosVel.position;
        rightPos = rightPosVel.position;
        centerPos = centerPosVel.position;

        telemetry.addData("Theta", theta);
        telemetry.addData("X", x);
        telemetry.addData("Y", y);
    }


    public void velupdate() {
        // https://gm0.org/en/latest/docs/software/concepts/odometry.html
        // THE EXTRA STEP
        // calculate the arc generated by this movement instead of just assuming that there's a
        // really low loop time
        PositionVelocityPair leftPosVel = left.getPositionAndVelocity();
        PositionVelocityPair rightPosVel = right.getPositionAndVelocity();
        PositionVelocityPair centerPosVel = center.getPositionAndVelocity();
        // in ticks
        double dLeft = leftPosVel.position - leftPos;
        double dRight = rightPosVel.position - rightPos;
        double dCenter = centerPosVel.position - centerPos;
        double xDist = Math.abs(OdometryConfig.LEFT_X_POSITION - OdometryConfig.RIGHT_X_POSITION);


        // same as dTheta, but phi is used in the paper
        double phi = (dLeft - dRight) / xDist;
        double dx, dy;
        // Avoid divide by zero, but only if it's zero
        if(phi == 0) {
            dx = (dLeft + dRight) / 2;
            dy = dCenter;
        } else {
            dx = (
                    (Math.cos(phi)-1) *
                    (dCenter-(OdometryConfig.CENTER_Y_POSITION*phi)) /
                    phi
            ) + (
                    (dLeft + dRight) * Math.sin(phi) /
                    (2 * phi)
            );
            dy = (
                    Math.sin(phi) *
                    (dCenter-(OdometryConfig.CENTER_Y_POSITION*phi)) /
                    phi
            ) + (
                    (dLeft + dRight) * (1-Math.cos(phi)) /
                    (2 * phi)
            );
        }

        double theta = getHeading() + phi;
        Vector2d gradient = Vector.rotateVector(new Pose2d(dx, dy, theta));

        double x = getXPosition() + gradient.x;
        double y = getYPosition() + gradient.y;

        currentPose = new Pose2d(x, y, theta);
        leftPos = leftPosVel.position;
        rightPos = rightPosVel.position;
        centerPos = centerPosVel.position;

        telemetry.addData("dLeft", dLeft);
        telemetry.addData("dRight", dRight);
        telemetry.addData("dCenter", dCenter);
        telemetry.addData("dx", dx);
        telemetry.addData("dy", dy);
    }

    private void constAccelUpdate() {
        throw new NotImplementedError("Constant Acceleration Odometry mode is not yet written since Michael is too scared of that insanity");
    }
}