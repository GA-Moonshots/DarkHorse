package org.firstinspires.ftc.teamcode.sensors.localizers;

import com.acmerobotics.roadrunner.Pose2d;
import com.acmerobotics.roadrunner.Vector2d;
import com.acmerobotics.roadrunner.ftc.Encoder;
import com.acmerobotics.roadrunner.ftc.OverflowEncoder;
import com.acmerobotics.roadrunner.ftc.PositionVelocityPair;
import com.acmerobotics.roadrunner.ftc.RawEncoder;
import com.qualcomm.robotcore.hardware.DcMotorEx;

import org.firstinspires.ftc.teamcode.config.Constants;
import org.firstinspires.ftc.teamcode.config.OdometryConfig;
import org.firstinspires.ftc.teamcode.core.CoreLocalizer;
import org.firstinspires.ftc.teamcode.core.CoreOpMode;
import org.firstinspires.ftc.teamcode.core.math.Vector;

import kotlin.NotImplementedError;

public class ThreeWheelLocalizer extends CoreLocalizer {
    private final Encoder left, right, center;
    private double leftPos, rightPos, centerPos;

    public ThreeWheelLocalizer(CoreOpMode opMode) {
        super(opMode);

        left = new OverflowEncoder(new RawEncoder(opMode.hardwareMap.get(DcMotorEx.class, Constants.LEFT_ODOMETRY_NAME)));
        right = new OverflowEncoder(new RawEncoder(opMode.hardwareMap.get(DcMotorEx.class, Constants.RIGHT_ODOMETRY_NAME)));
        center = new OverflowEncoder(new RawEncoder(opMode.hardwareMap.get(DcMotorEx.class, Constants.CENTER_ODOMETRY_NAME)));
    }

    public void update() {
        PositionVelocityPair leftPosVel = left.getPositionAndVelocity();
        PositionVelocityPair rightPosVel = right.getPositionAndVelocity();
        PositionVelocityPair centerPosVel = center.getPositionAndVelocity();

        // left = dx+L*dTheta/2
        // right = dx-L*dTheta/2
        // center = dy +BdTheta

        double dLeft = leftPosVel.position - leftPos;
        double dRight = rightPosVel.position - rightPos;
        double dCenter = centerPosVel.position - centerPos;

        double xDist = Math.abs(OdometryConfig.LEFT_X_POSITION - OdometryConfig.RIGHT_X_POSITION);

        double dx = (dRight * OdometryConfig.LEFT_X_POSITION) - (dLeft * OdometryConfig.RIGHT_X_POSITION) / xDist;
        double dTheta = (dRight - dLeft) / xDist;
        double dy = dCenter - OdometryConfig.CENTER_Y_POSITION * dTheta;

        // Vector Rotation based on new theta
        double theta = currentPose.heading.toDouble() + dTheta;
        Vector2d gradient = Vector.rotateVector(new Pose2d(dx, dy, theta));

        double x = currentPose.position.x + gradient.x;
        double y = currentPose.position.y + gradient.y;

        currentPose = new Pose2d(x, y, theta);
        leftPos = leftPosVel.position;
        rightPos = rightPosVel.position;
        centerPos = centerPosVel.position;
    }


    private void constVelUpdate() {
        // https://gm0.org/en/latest/docs/software/concepts/odometry.html
        // THE EXTRA STEP
        // calculate the arc generated by this movement instead of just assuming that there's a
        // really low loop time
        PositionVelocityPair leftPosVel = left.getPositionAndVelocity();
        PositionVelocityPair rightPosVel = right.getPositionAndVelocity();
        PositionVelocityPair centerPosVel = center.getPositionAndVelocity();
        // in ticks
        double dLeft = leftPosVel.position - leftPos;
        double dRight = rightPosVel.position - rightPos;
        double dCenter = centerPosVel.position - centerPos;
        double xDist = Math.abs(OdometryConfig.LEFT_X_POSITION - OdometryConfig.RIGHT_X_POSITION);


        // same as dTheta, but phi is used in the paper
        double phi = (dLeft - dRight) / xDist;
        double dx, dy;
        // Avoid divide by zero, but only if it's zero
        if(phi == 0) {
            dx = (dLeft + dRight) / 2;
            dy = dCenter;
        } else {
            dx = (
                    (Math.cos(phi)-1) *
                    (dCenter-(OdometryConfig.CENTER_Y_POSITION*phi)) /
                    phi
            ) + (
                    (dLeft + dRight) * Math.sin(phi) /
                    (2 * phi)
            );
            dy = (
                    Math.sin(phi) *
                    (dCenter-(OdometryConfig.CENTER_Y_POSITION*phi)) /
                    phi
            ) + (
                    (dLeft + dRight) * (1-Math.cos(phi)) /
                    (2 * phi)
            );
        }

        double theta = getHeading() + phi;
        Vector2d gradient = Vector.rotateVector(new Pose2d(dx, dy, theta));

        // In inches?

        double x = getXPosition() + (gradient.x / OdometryConfig.TICKS_PER_INCH);
        double y = getYPosition() + (gradient.y / OdometryConfig.TICKS_PER_INCH);

        currentPose = new Pose2d(x, y, theta);
        leftPos = leftPosVel.position;
        rightPos = rightPosVel.position;
        centerPos = centerPosVel.position;
    }

    private void constAccelUpdate() {
        throw new NotImplementedError("Constant Acceleration Odometry mode is not yet written since Michael is too scared of that insanity");
    }
}